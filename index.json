[{"content":"Intro Although it looks slightly overkill, the idea behind this design was to check if my NoC (Network-on-chip) RTL would work into a real hardware \u0026ldquo;FPGA\u0026rdquo;. Then some weeks ago, during my summer holidays, I decided to put some effort into that, without any fancy approach but using a well-known RV core and my largest FPGA. So far till that moment, the only confirmation that the design was working as it\u0026rsquo;s supposed to be, was through some python tests that were implemented to cover different aspects. Here below there is a resume of my short journey of implementing this MPSoC design.\nThe components To compose the design, I wouldn\u0026rsquo;t want to use anything proprietary or platform-dependent, such as Xilinx/Altera IPs, my main target was to design it all with open source Github based components. Furthermore, I was planning to use an open-source simulation tool like Verilator once if any user wants to try it out, no vendor thing would block from doing it. My only tool exception was to target my largest FPGA synthesis, where I\u0026rsquo;ve used Vivado to synthesize the design. It was in the queue to test how it\u0026rsquo;d be with Symbiflow/Project x-ray, however as I wasn\u0026rsquo;t planning to spend an amount of time on this, I\u0026rsquo;ve decided by the simple way IMO.\nThe tiles For this project, the first idea I had was the one I stayed with, so I had in my mind: build two tiles, one slave and one master and replicate it many times. With the master tile having a bit more stuff like JTAG and a larger data RAM. Also instead of having an Instruction RAM, I decided to use a boot ROM for the slave tiles with a simple program to answer master calls through the NoC. Again, nothing fancy just to see if I could request from the master to all slaves in the network. For the slave tile, I defined the following components:\n AXI4 interconnect bus AXI4 memory VexRISCV core (smallest cfg) with some tweaks to enable AXI4 and mtvec[RW] - RV32I AXI4 NI Network-Interface with RaveNoC  Well, not that different for the master tile this is what I chose:\n AXI4 interconnect bus AXI4 memory VexRISCV core (simple cfg) mult/div extension, full barrel shifter and has JTAG AXI4 NI Network-Interface with RaveNoC  So that was all, pretty much straightforward hardware, nothing custom or different from what\u0026rsquo;s already available on the web. With all that in place, I just encapsulated the NoC in the top and have added the generates, having in the end, a smaller top which has listed all the modules and instantiates a configurable number of tiles depending upon NoC size/cfg. With the design ready, it was time to get some waves to check if everything was moving in a good direction.\nThe final design with all modules with a 9x9 RaveNoC is the following one: Simulation For the simulation, as I had tried in the past, Verilator was my best choice, once it\u0026rsquo;s open-source and easy to write testbenches in cpp. Quickly copying and pasting from my previous personal projects, my tb has nothing but the dut instantiation and a modified version of my ELF loader, which I was using at first to test boot ROM of slave tiles. Later on, I changed to only load the ELF into the master tile once the boot ROM on the slaves was working as it suppose to. To enable my cpp ELF loader to write into the memories, I implemented the functions below at the top of the tiles calling these in the tb at sim #t0.\n// synthesis translate_off  function automatic void writeWordIRAM(addr_val, word_val); /* verilator public */ logic [31:0] addr_val; logic [31:0] word_val; u_ram_instr_rv.u_ram.mem[addr_val] = word_val; endfunction function automatic void writeWordDRAM(addr_val, word_val); /* verilator public */ logic [31:0] addr_val; logic [31:0] word_val; //u_ram_rv.u_ram.mem[addr_val] = word_val;  endfunction // synthesis translate_on It\u0026rsquo;s considerable to mention that the comment \u0026quot;// synthesis translate_on/off\u0026quot; was there to force Vivado to ignore these constructions when implementing. Technically that\u0026rsquo;s not required because it\u0026rsquo;s going to do that anyway although if you have hierarchical mention of the memory arrays like I do there, the tool will not infer BRAMs, creating memories with LUTs what means that you\u0026rsquo;re 1-wasting FPGA resources and 2-increasing the size of your design once it will consume a lot of logic slices for that.\nMy first attempt to communicate with the slaves through the NoC wasn\u0026rsquo;t that good, I have forgotten to change mtvec CSR to point to the location where it was declared my external IRQ function. Thankfully after two/three cups of coffee, I was able to see the obvious in the sims. Since the beginning, I didn\u0026rsquo;t want to code a complex handshake, so what I decided to do was to implement the following protocol between the single master and the 99x slaves:\nAs the master tile has a JTAG interface I could easily switch from one slave coordinates to another without any worries, once it was as easy as compiling it again and loading through the I/F in the FPGA or through an ELF loader in my tb. With the boot ROM working and the master sending the packets correctly in the NoC, I saw it working after some runs. In the image below you can see the design being released from the reset, then the last slave in the NoC [aka x=9/y=9] receives an IRQ, reads the packet, operates on it, and sends it back to the master with the payload modified.\nVerilator hint for medium/large designs I guess worth it to explain here something I have done to speed up the verilation (process to convert from Verilog/RTL to cpp classes) when playing with my sims. When building something that can be considered a medium size design, the tool might take ages to run all the steps into conversion so I found something useful in the Verilator\u0026rsquo;s FAQ. This a way to indicate to Verilator that you have a design that\u0026rsquo;s repeated many times and it can be processed into an hierarchical way or something like that. In my case, it changed from 120+ mins to 15 mins worst case. One of the drawbacks is that you need to remember to change the configuration file every time you change the wrapper name where is encapsulated the repetitive design because the output error seems a bit odd and it doesn\u0026rsquo;t explain to you explicitly why it\u0026rsquo;s failing to build (was almost mad when I discovered that xD). Another disadvantage is that you lose visibility of your structs and nested modules, although I suppose when you are building something like that, you pretty much already know what\u0026rsquo;s going on inside there.\nThe design and the FPGA When I first saw it working on sims, I was pretty much confident it\u0026rsquo;d work straight away on the FPGA once I wasn\u0026rsquo;t adding any MMCM, clock generators, or anything vendor/part-number specific. However, I didn\u0026rsquo;t start with 100x cores in my first synth and I knew that would fit in my board, unfortunately, I don\u0026rsquo;t have a crystal ball. So I started with an 8x8 design and discovered that my NoC with 2x flits buffer was consuming a considerable amount of the whole design LUT space. And my FPGA is a Kintex 7 - xc7k325tffg676-2 which has around \u0026gt;203k LUT in total. Having an easily configurable NoC was the advantage on playing with the parameters to see how big I could increase my design and/or shrink some internal buffers. After several tries and decreasing my initial VexRISCV core parameters to the smallest possible option I could synthesize with 100x RISC-V cores running @ 100MHz. Again, the initial idea wasn\u0026rsquo;t to push 100% utilization but if it\u0026rsquo;s easy to change and it\u0026rsquo;s interesting to know, why not?!. My final hierarchical report by area utilization was this one in the end.\nIn the end, I had only 3% LUT space left! Still would fit another VexRISCV with steroids, but I was too lazy to try that, maybe another time. The whole congestion/timing in the design wasn\u0026rsquo;t much awful, as I was running in a low clock freq. for this PN (@100MHz). As you can see in the image above, almost every logical slice has something placed, let\u0026rsquo;s give some thumbs up to Xilinx\u0026rsquo;s tools at least. xD\nFuseSoC My main source of headaches when dealing with vendor\u0026rsquo;s tools is to call TCL scripts and face a heterogeneous set of issues about wrong setup, missing files, and a bunch of other \u0026ldquo;waste of time\u0026rdquo; stuff. I don\u0026rsquo;t remember well but most likely that was my motivation when I started looking for a replacement solution. Thankfully there\u0026rsquo;re impressive engineers such as Olof which started developing some years ago a python package tool called FuseSoC that works as a mixer i.e it takes all your old past frustrations with FPGA vendors + your disruptive RTLs and your ctrl+c/v constraints file and builds for you a bitstream.\nEventually, when it finishes it\u0026rsquo;ll also try to program your device magically, it\u0026rsquo;s fantastic and worth giving a try if you never saw it before. Your only duty as a user is to create a YAML core config file that will list all your RTLs/constraints/PN and point that to the tool. Of course, it\u0026rsquo;s implicit you need to have the vendor tool installed for your FPGA, although it\u0026rsquo;s magic, the hocus pocus about a license is still required if you\u0026rsquo;re in Xilinx/Altera\u0026rsquo;s world. If you\u0026rsquo;re willing to build this MPSoC for your FPGA, just be careful when launching a run once it takes some time to finish it\u0026hellip;\nDebugging with real-hardware After programming the 10.2MB bitstream in the FPGA through Vivado (need to try through open FPGA loader) and connecting the JTAG adapter in the headers, it was time for debugging the program with a real emulation. One of the advantages of using VexRISCV is that the debug module is easy to use and it implements methods to access the busses of the core and put breakpoints/watchpoints all over your SW. For the use with my design, I just downloaded and built their openocd version and in no time was able to start debugging.\nTo connect the jtag adapter with openocd and start the gdb server:\n$ mpsoc_example/sw/openocd_vexriscv -f mpsoc_example/sw/esp-prog.cfg -c \u0026#34;set MPSOC /home/aignacio/mpsoc_example/sw/cpu0.yaml\u0026#34; -f mpsoc_example/sw/mpsoc.cfg And to launch gdb connecting to the server and sending the ELF file:\n$ riscv64-unknown-elf-gdb output/tile_master.elf -ex \u0026#34;target remote localhost:3333\u0026#34; -ex \u0026#34;load\u0026#34; With the gdb session opened, I just set a breakpoint at the IRQ after reading the RX NI buffer of NoC to see what was the returned packet content.\n(gdb) b main.c:47 (gdb) c #Run till bp (gdb) p/x buffer #print in hex the buffer value \u0026hellip;finally here\u0026rsquo;s my debug session with the results when talking with the FPGA As it can be seen, the last slave tile answers properly as it is supposed to be. I also tried with different slaves and had the same results changing of course the source X/Y in the payload, all operating as they should.\nTo have access to the design, FuseSoC configuration file, sims, and testbench, please check this repository.\n","permalink":"https://aignacio.com/posts/hdls/mpsoc_riscv/","summary":"I\u0026rsquo;m too lazy to write a summary","title":"How to fit 100x RISC-V cores into an FPGA"},{"content":"   Intro With the growth of complexity of the digital circuits, a single SoC (System-On-Chip) can have multiple subsystems and power rails [2]. Quite often is the usage of dynamic voltage and clock scaling, where the SoC will switch between different clock frequencies or clock modes according to the requirements of usage. In the mobile market, if the user wants to play games on the device, some specific subsystems must run at high-performance mode what in general means higher clock speed and no low power techniques active (e.g clock-gating or retention power gating[4]). Although if a low processing task is the main one, lower clock speeds are the right decision to make in different SS.\nIn all the scenarios mentioned, the SoC needs to handle usually multiple \u0026ldquo;clock islands\u0026rdquo; within the same chip. It means that CDC (clock domain crossing) issues must be taken into account when designing the interactions between busses, memories, and digital circuits [3]. Some fundamentals about CDC are quite old and although they look a bit obvious for most engineers, it\u0026rsquo;s still common in the universities, and sometimes in the industry people trying to solve complex issues with simple synchronizers without carrying about details.\nConsidered the mentioned before, I\u0026rsquo;ve decided recently to revisit some CDC papers and write about some simple gotchas that I didn\u0026rsquo;t remember anymore. At the end of this post, it\u0026rsquo;s also present my simple CDC library of common components that can be used to deal with daily issues.\nBe careful how you connect the synchronizer circuit when crossing clock boundaries\u0026hellip; Well, as mentioned in [1], if the signal is crossing clock boundaries and it\u0026rsquo;s connected to a set of combinatorial logic the chances of being unstable are considerable, once it may be still settling due to the datapath. Thus it\u0026rsquo;s fundamental to have a flip-flop to synchronize every signal that is driven by combo logic before sending it to the new clock domain through the synchronizer. For instance, let\u0026rsquo;s suppose the following scenario:\nIn a case like this, we cannot simply connect the output in the clock domain A straight to the synchronizer in the clock domain B once it may capture small bursts of the data A switching through the combinatorial datapath. Due to that, the correct approach to avoid any issues is to register it right before connecting to the synchronizer circuit:\nOnly 2FF might not help you when going from fast to slow domain\u0026hellip; There is an additional consideration that you should take care of when crossing from fast to slow clock domains using the 2FF circuit. First of all, if the pulse is a single clock cycle in the fast clock domain, you might not see it captured by the first flop of the synchronizer. Because of that, the recommended approach to solve that from [1] is to drive (assert for a min. width period) the input signal (the one in the fast clock domain) at least 1.5x the period of the receiving clock frequency (slow domain). Such design is also known as an open-loop solution once we don\u0026rsquo;t have any req/ack or valid/ready handshake between clock crossing boundaries.\nA quick workaround solution is to drive the signal for a long enough period to ensure that it\u0026rsquo;ll be sampled by the flops in the slow clock domain.\nAnother solution that addresses this issue is the closed-loop 2FF synchronizer. In resume on this approach, we have feedback in the fast clock domain from the synchronizer clocked by the slow domain, making sure that the data has transferred and it\u0026rsquo;s stable. (see the design cdc_2ff_w_ack.sv).\nWhen multiple bits are needed to cross clock domain boundaries, don\u0026rsquo;t simply use 2FF\u0026hellip; One of the most common mistakes when trying to use the 2FF synchronizer is the idea of using it for multi-bit signals. Although all designs that are part of my small library have a DATA_WIDTH parameter, it is not recommended to use this if your idea is to send busses because of the unwanted skew issues. Even the most accurate ASIC processes cannot guarantee that all flops in a die will have the same electrical characteristics. What clearly can lead to different bits being sampled at different clock cycles and messing with the logic in the circuits. Clifford E. details in 3x different categories all the solutions for multi-bit synchronization.\n  Multi-bit signal consolidation. Where possible, consolidate multiple CDC bits into 1bit CDC signals. Multi-cycle path formulations. Use a synchronized load signal to safely pass multiple CDC bits. Pass multiple CDC bits using gray codes.   Shortly, we can resume the first one as the idea of joining multiple-meaning signals into a single one and use the 2FF just for this particular signal. For instance, if your design has a load and an enable both could be fused into a single signal called Ld_En once it\u0026rsquo;s known that they\u0026rsquo;ll be asserted together, then your work is to pass this through a 2FF circuit.\nIn the second category, we have the concept of sending all the data straight to a flop in the receiving clock domain and only synchronize a single-bit load signal. There are different variations with additional acknowledge signal and some custom circuit for synchronization but the idea surrounds the same as mentioned.\nThe asynchronous FIFO In my opinion and what I\u0026rsquo;ll detail a bit more here, the third category is the most used. The other ones are interesting however from my understanding, gray code counters are simple to understand and the asynchronous FIFO that I designed can be very flexible matching different needs. This async FIFO uses gray counters in the read and write pointers and these are the only flops that will be converted from one domain to another. The background reason for using gray counters is that for every increment only a single bit changes, thus eliminate the issue when crossing multi-bit signals through different clock domains.\nThe design has a single array that stores the data that\u0026rsquo;ll be transferred from one clock domain to another and two pointers (rd/wr). On one side we have the write clock domain, which is responsible to check if the FIFO is full before writing into it, and on the other side the read clock domain, which ensures that the FIFO is not empty before allowing a read to happen through the interface. In the write clock domain, the wr_data_i/wr_en_i should be connected to the sending circuit and in the read clock domain, the rd_en_i/rd_data_o.\nTo compare the pointers for the full flag on the write side, we bring the read pointer to the write clock domain by using a 2FF circuit but first, we encode the read pointer to gray encoding. The same happens when we need to check for the empty flag, where we then encode the write pointer and synchronize in the read clock domain through the 2FF.\nTwo parameters on top can configure the design for different applications, SLOTS sets the number of depth and the WIDTH of each slot in bits. It important to highlight that SLOTS have to be a power of 2 starting from 2 e.g 2,4,8,16\u0026hellip; For this parameter, if the clock frequencies, the burst size of the operations, and the number of idle clock cycles are known, you can simply use the following formula.\n$$ FIFO\\ depth\\ =\\ BS\\ -BS\\ *\\lgroup\\frac{Read\\ Clock\\ Freq.}{Write\\ Clock\\ Freq.*Idle\\ cycles}\\rgroup $$\nFor instance, let\u0026rsquo;s consider the following scenario:\n Burst size max = 256 (AXI4) Write freq. = 200MHz Read freq. = 100MHz Idle cycles = 1 (no idle cycles)  $$ FIFO\\ depth\\ =\\ 256-256*\\lgroup\\frac{100}{200*1}\\rgroup=\\ 128 $$\nUse case example for bus conversion In my NoC (Network-on-chip) project I had to add a synchronizer between each processing element and the network itself. To accomplish this task of working with two different clock frequencies, I encapsulated the flits (smallest NoC data unit) into two asynchronous FIFOs, one in a direction processing element (CPU/Small SoC) to NoC and from NoC to processing element like the diagram below. The code for this design is available here.\nIf the intention is to convert a whole bus like for instance, AXI4 as it was done here by ZipCPU it will be needed at least 5x AFIFOs, one for each channel of the AXI4!\nCDC - library of designs All the components mentioned above are available here, the designs are in System Verilog and there\u0026rsquo;re some simples tests along to confirm the expected basic behavior.\n   Design Description     cdc_2ff_sync.sv 2FF synchronizer circuit   cdc_3ff_sync.sv 3FF synchronizer circuit   \u0007cdc_2ff_w_ack.sv 2FF synchronizer w/ACK feedback   cdc_async_fifo.sv Asynchronous FIFO for multi-bit cdc    References  Clifford paper about CDC Cadence TP about CDC Practical design for transferring signals between clock domains Low power design techniques  ","permalink":"https://aignacio.com/posts/hdls/cdc_lib/","summary":"Some thoughts about common CDC issues and the lib. of components","title":"My two cents about CDC"},{"content":"I\u0026rsquo;m not a writer but I did something indeed\u0026hellip; This blog is not my first one. I started blogging in 2014 back when I was a graduate student with low resources (money+time) and the only thing I had was a passion for electronics. My first blog is called “Embedded Systems Platform” and the funny part is that it’s still active through the Blogspot platform. It was a nice platform to write but way too bugged with low-quality render on mobile platforms. On this blog, I tried from wireless firmware to hardware hacking and some network-level protocols, I think during that time, hardware was very far from something I could imagine working with. Usually, for me hardware was PCBs and analog things, never had the impression I could design something like ASICs.\nAfter that, I moved to the ghost platform, something hundreds of years better to edit, review, and publish posts full of links and images. This blog was part of my transition from software to hardware definitely (you can see clearly that by the last posts I was writing). Now with the URL https://blog.aignacio.com, an amazing bought domain that I still pay to GoDaddy (btw, as the time is passing they increase more and more the price –')\nThis blog was better but to manage such infrastructure I had to deal with Traefik, Portainer, Docker, and a bunch of other software things like reverse proxy, Nginx, etc…Well I’m also not mentioning the monthly server bill to host all these software that I was barely using.\nI’m not a full-stack / DevOps engineer… This is the main reason why my last blog was abandoned, I was tired moreover sick (too much stress) of updating all the software and keeping track manually of the versions. Writing a post about HDL was out of my scope once that every time just to access the platform it was chaos, with updates to do or some other issue to solve. Thus I left it all with the hope of one day returning with a simpler platform, or an easy way of writing and publishing it without needing to read 1000 tutorials about how to handle new errors.\n…and so we have GitHub pages! Well, now again, I will try to return to creating new posts but with more focus on what I’m working with, hardware more precisely HDL and FPGAs. This platform of GitHub pages + Hugo is so much easier than the previous solution that I got excited just to give it a try and see how it goes. So far, I’m looking forward to testing it and start writing again!\nbut why blogging? I mean, you aren’t making money with it! A friend of mine asked me this question and I think it worth summarizing some of the reasons why, in my toilet opinion, I think it worth blogging:\n I’m not a native English speaker: I think this one is pretty clear due to my non-singular recurrent typos =). Because of that, I think blogging can help to practice it more and helps to improve the brain parser for lexical errors or just writing skills. Sharing knowledge makes you learn: I had several mind-blowing moments while trying to transfer knowledge to people that I realize how important is to share it through a post. Every time you think and convert this thinking into words, you see the path you went through and you reinforce such connections more and more…If you don’t believe me, try training with an old engineer and see how easy all the sequence of instructions will come out of his mouth. Unless you have an SSD in your brain, it’ll take time to remember: Sometimes when you are trying to do a side project you can risk and have nice insights of proposals that may not be feasible for you to try while at your work. Thus having a post or a repository with all the steps and information may help you to solve it faster rather than starting again from scratch.  That’s the sum of my thoughts and the reason why I abandoned this for 2 years. Let’s see how it goes this time… ","permalink":"https://aignacio.com/posts/others/return/","summary":"The reason why blogging again\u0026hellip;","title":"Return blogging"}]
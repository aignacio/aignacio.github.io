<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>How to fit 100x RISC-V cores into an FPGA | aignacio</title><meta name=keywords content="hdl"><meta name=description content="I&rsquo;m too lazy to write a summary"><meta name=author content="Anderson Ignacio"><link rel=canonical href=https://aignacio.com/posts/hdls/mpsoc_riscv/><link crossorigin=anonymous href=/assets/css/stylesheet.min.2d6dbfc6e0f8a1db1c9d082a76dc11d094328cf63f247bbc2421dfaa7f2bb170.css integrity="sha256-LW2/xuD4odscnQgqdtwR0JQyjPY/JHu8JCHfqn8rsXA=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.min.7680afc38aa6b15ddf158a4f3780b7b1f7dde7e91d26f073e6229bb7a0793c92.js integrity="sha256-doCvw4qmsV3fFYpPN4C3sffd5+kdJvBz5iKbt6B5PJI=" onload=hljs.initHighlightingOnLoad()></script><link rel=icon href=https://aignacio.com/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://aignacio.com/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://aignacio.com/favicon-32x32.png><link rel=apple-touch-icon href=https://aignacio.com/apple-touch-icon.png><link rel=mask-icon href=https://aignacio.com/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><meta name=generator content="Hugo 0.85.0"><script async src="https://www.googletagmanager.com/gtag/js?id=G-1TE0B0G9DZ"></script><script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag('js',new Date),gtag('config','G-1TE0B0G9DZ',{anonymize_ip:!1})}</script><meta property="og:title" content="How to fit 100x RISC-V cores into an FPGA"><meta property="og:description" content="I&rsquo;m too lazy to write a summary"><meta property="og:type" content="article"><meta property="og:url" content="https://aignacio.com/posts/hdls/mpsoc_riscv/"><meta property="og:image" content="https://aignacio.com/posts/hdls/mpsoc_riscv/img/mpsoc_100x_white.png"><meta property="article:section" content="posts"><meta property="article:published_time" content="2021-07-10T13:10:00+01:00"><meta property="article:modified_time" content="2021-07-10T13:10:00+01:00"><meta property="og:see_also" content="https://aignacio.com/posts/hdls/cdc_lib/"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://aignacio.com/posts/hdls/mpsoc_riscv/img/mpsoc_100x_white.png"><meta name=twitter:title content="How to fit 100x RISC-V cores into an FPGA"><meta name=twitter:description content="I&rsquo;m too lazy to write a summary"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://aignacio.com/posts/"},{"@type":"ListItem","position":2,"name":"HDL","item":"https://aignacio.com/posts/hdls/"},{"@type":"ListItem","position":3,"name":"How to fit 100x RISC-V cores into an FPGA","item":"https://aignacio.com/posts/hdls/mpsoc_riscv/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"How to fit 100x RISC-V cores into an FPGA","name":"How to fit 100x RISC-V cores into an FPGA","description":"I\u0026rsquo;m too lazy to write a summary","keywords":["hdl"],"articleBody":"Intro Although it looks slightly overkill, the idea behind this design was to check if my NoC (Network-on-chip) RTL would work into a real hardware “FPGA”. Then some weeks ago, during my summer holidays, I decided to put some effort into that, without any fancy approach but using a well-known RV core and my largest FPGA. So far till that moment, the only confirmation that the design was working as it’s supposed to be, was through some python tests that were implemented to cover different aspects. Here below there is a resume of my short journey of implementing this MPSoC design.\nThe components To compose the design, I wouldn’t want to use anything proprietary or platform-dependent, such as Xilinx/Altera IPs, my main target was to design it all with open source Github based components. Furthermore, I was planning to use an open-source simulation tool like Verilator once if any user wants to try it out, no vendor thing would block from doing it. My only tool exception was to target my largest FPGA synthesis, where I’ve used Vivado to synthesize the design. It was in the queue to test how it’d be with Symbiflow/Project x-ray, however as I wasn’t planning to spend an amount of time on this, I’ve decided by the simple way IMO.\nThe tiles For this project, the first idea I had was the one I stayed with, so I had in my mind: build two tiles, one slave and one master and replicate it many times. With the master tile having a bit more stuff like JTAG and a larger data RAM. Also instead of having an Instruction RAM, I decided to use a boot ROM for the slave tiles with a simple program to answer master calls through the NoC. Again, nothing fancy just to see if I could request from the master to all slaves in the network. For the slave tile, I defined the following components:\n AXI4 interconnect bus AXI4 memory VexRISCV core (smallest cfg) with some tweaks to enable AXI4 and mtvec[RW] - RV32I AXI4 NI Network-Interface with RaveNoC  Well, not that different for the master tile this is what I chose:\n AXI4 interconnect bus AXI4 memory VexRISCV core (simple cfg) mult/div extension, full barrel shifter and has JTAG AXI4 NI Network-Interface with RaveNoC  So that was all, pretty much straightforward hardware, nothing custom or different from what’s already available on the web. With all that in place, I just encapsulated the NoC in the top and have added the generates, having in the end, a smaller top which has listed all the modules and instantiates a configurable number of tiles depending upon NoC size/cfg. With the design ready, it was time to get some waves to check if everything was moving in a good direction.\nThe final design with all modules with a 9x9 RaveNoC is the following one: Simulation For the simulation, as I had tried in the past, Verilator was my best choice, once it’s open-source and easy to write testbenches in cpp. Quickly copying and pasting from my previous personal projects, my tb has nothing but the dut instantiation and a modified version of my ELF loader, which I was using at first to test boot ROM of slave tiles. Later on, I changed to only load the ELF into the master tile once the boot ROM on the slaves was working as it suppose to. To enable my cpp ELF loader to write into the memories, I implemented the functions below at the top of the tiles calling these in the tb at sim #t0.\n// synthesis translate_off  function automatic void writeWordIRAM(addr_val, word_val); /* verilator public */ logic [31:0] addr_val; logic [31:0] word_val; u_ram_instr_rv.u_ram.mem[addr_val] = word_val; endfunction function automatic void writeWordDRAM(addr_val, word_val); /* verilator public */ logic [31:0] addr_val; logic [31:0] word_val; //u_ram_rv.u_ram.mem[addr_val] = word_val;  endfunction // synthesis translate_on It’s considerable to mention that the comment \"// synthesis translate_on/off\" was there to force Vivado to ignore these constructions when implementing. Technically that’s not required because it’s going to do that anyway although if you have hierarchical mention of the memory arrays like I do there, the tool will not infer BRAMs, creating memories with LUTs what means that you’re 1-wasting FPGA resources and 2-increasing the size of your design once it will consume a lot of logic slices for that.\nMy first attempt to communicate with the slaves through the NoC wasn’t that good, I have forgotten to change mtvec CSR to point to the location where it was declared my external IRQ function. Thankfully after two/three cups of coffee, I was able to see the obvious in the sims. Since the beginning, I didn’t want to code a complex handshake, so what I decided to do was to implement the following protocol between the single master and the 99x slaves:\nAs the master tile has a JTAG interface I could easily switch from one slave coordinates to another without any worries, once it was as easy as compiling it again and loading through the I/F in the FPGA or through an ELF loader in my tb. With the boot ROM working and the master sending the packets correctly in the NoC, I saw it working after some runs. In the image below you can see the design being released from the reset, then the last slave in the NoC [aka x=9/y=9] receives an IRQ, reads the packet, operates on it, and sends it back to the master with the payload modified.\nVerilator hint for medium/large designs I guess worth it to explain here something I have done to speed up the verilation (process to convert from Verilog/RTL to cpp classes) when playing with my sims. When building something that can be considered a medium size design, the tool might take ages to run all the steps into conversion so I found something useful in the Verilator’s FAQ. This a way to indicate to Verilator that you have a design that’s repeated many times and it can be processed into an hierarchical way or something like that. In my case, it changed from 120+ mins to 15 mins worst case. One of the drawbacks is that you need to remember to change the configuration file every time you change the wrapper name where is encapsulated the repetitive design because the output error seems a bit odd and it doesn’t explain to you explicitly why it’s failing to build (was almost mad when I discovered that xD). Another disadvantage is that you lose visibility of your structs and nested modules, although I suppose when you are building something like that, you pretty much already know what’s going on inside there.\nThe design and the FPGA When I first saw it working on sims, I was pretty much confident it’d work straight away on the FPGA once I wasn’t adding any MMCM, clock generators, or anything vendor/part-number specific. However, I didn’t start with 100x cores in my first synth and I knew that would fit in my board, unfortunately, I don’t have a crystal ball. So I started with an 8x8 design and discovered that my NoC with 2x flits buffer was consuming a considerable amount of the whole design LUT space. And my FPGA is a Kintex 7 - xc7k325tffg676-2 which has around 203k LUT in total. Having an easily configurable NoC was the advantage on playing with the parameters to see how big I could increase my design and/or shrink some internal buffers. After several tries and decreasing my initial VexRISCV core parameters to the smallest possible option I could synthesize with 100x RISC-V cores running @ 100MHz. Again, the initial idea wasn’t to push 100% utilization but if it’s easy to change and it’s interesting to know, why not?!. My final hierarchical report by area utilization was this one in the end.\nIn the end, I had only 3% LUT space left! Still would fit another VexRISCV with steroids, but I was too lazy to try that, maybe another time. The whole congestion/timing in the design wasn’t much awful, as I was running in a low clock freq. for this PN (@100MHz). As you can see in the image above, almost every logical slice has something placed, let’s give some thumbs up to Xilinx’s tools at least. xD\nFuseSoC My main source of headaches when dealing with vendor’s tools is to call TCL scripts and face a heterogeneous set of issues about wrong setup, missing files, and a bunch of other “waste of time” stuff. I don’t remember well but most likely that was my motivation when I started looking for a replacement solution. Thankfully there’re impressive engineers such as Olof which started developing some years ago a python package tool called FuseSoC that works as a mixer i.e it takes all your old past frustrations with FPGA vendors + your disruptive RTLs and your ctrl+c/v constraints file and builds for you a bitstream.\nEventually, when it finishes it’ll also try to program your device magically, it’s fantastic and worth giving a try if you never saw it before. Your only duty as a user is to create a YAML core config file that will list all your RTLs/constraints/PN and point that to the tool. Of course, it’s implicit you need to have the vendor tool installed for your FPGA, although it’s magic, the hocus pocus about a license is still required if you’re in Xilinx/Altera’s world. If you’re willing to build this MPSoC for your FPGA, just be careful when launching a run once it takes some time to finish it…\nDebugging with real-hardware After programming the 10.2MB bitstream in the FPGA through Vivado (need to try through open FPGA loader) and connecting the JTAG adapter in the headers, it was time for debugging the program with a real emulation. One of the advantages of using VexRISCV is that the debug module is easy to use and it implements methods to access the busses of the core and put breakpoints/watchpoints all over your SW. For the use with my design, I just downloaded and built their openocd version and in no time was able to start debugging.\nTo connect the jtag adapter with openocd and start the gdb server:\n$ mpsoc_example/sw/openocd_vexriscv -f mpsoc_example/sw/esp-prog.cfg -c \"set MPSOC /home/aignacio/mpsoc_example/sw/cpu0.yaml\" -f mpsoc_example/sw/mpsoc.cfg And to launch gdb connecting to the server and sending the ELF file:\n$ riscv64-unknown-elf-gdb output/tile_master.elf -ex \"target remote localhost:3333\" -ex \"load\" With the gdb session opened, I just set a breakpoint at the IRQ after reading the RX NI buffer of NoC to see what was the returned packet content.\n(gdb) b main.c:47 (gdb) c #Run till bp (gdb) p/x buffer #print in hex the buffer value …finally here’s my debug session with the results when talking with the FPGA As it can be seen, the last slave tile answers properly as it is supposed to be. I also tried with different slaves and had the same results changing of course the source X/Y in the payload, all operating as they should.\nTo have access to the design, FuseSoC configuration file, sims, and testbench, please check this repository.\n","wordCount":"1853","inLanguage":"en","image":"https://aignacio.com/posts/hdls/mpsoc_riscv/img/mpsoc_100x_white.png","datePublished":"2021-07-10T13:10:00+01:00","dateModified":"2021-07-10T13:10:00+01:00","author":{"@type":"Person","name":"Anderson Ignacio"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://aignacio.com/posts/hdls/mpsoc_riscv/"},"publisher":{"@type":"Organization","name":"aignacio","logo":{"@type":"ImageObject","url":"https://aignacio.com/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add('dark'):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove('dark'):window.matchMedia('(prefers-color-scheme: dark)').matches&&document.body.classList.add('dark')</script><noscript><style type=text/css>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:#1d1e20;--entry:#2e2e33;--primary:rgba(255, 255, 255, 0.84);--secondary:rgba(255, 255, 255, 0.56);--tertiary:rgba(255, 255, 255, 0.16);--content:rgba(255, 255, 255, 0.74);--hljs-bg:#2e2e33;--code-bg:#37383e;--border:#333}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><header class=header><nav class=nav><div class=logo><a href=https://aignacio.com/ accesskey=h title="aignacio (Alt + H)">aignacio</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=https://aignacio.com/archives title=Archive><span>Archive</span></a></li><li><a href=https://aignacio.com/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://aignacio.com/tags/ title=Tags><span>Tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://aignacio.com/>Home</a>&nbsp;»&nbsp;<a href=https://aignacio.com/posts/>Posts</a>&nbsp;»&nbsp;<a href=https://aignacio.com/posts/hdls/>HDL</a></div><h1 class=post-title>How to fit 100x RISC-V cores into an FPGA</h1><div class=post-meta>July 10, 2021&nbsp;·&nbsp;9 min&nbsp;·&nbsp;Anderson Ignacio</div></header><figure class=entry-cover><img loading=lazy srcset="https://aignacio.com/posts/hdls/mpsoc_riscv/img/mpsoc_100x_white_hucf5812b5d86ecfd34fcf071e0eca18dd_756053_360x0_resize_box_2.png 360w ,https://aignacio.com/posts/hdls/mpsoc_riscv/img/mpsoc_100x_white_hucf5812b5d86ecfd34fcf071e0eca18dd_756053_480x0_resize_box_2.png 480w ,https://aignacio.com/posts/hdls/mpsoc_riscv/img/mpsoc_100x_white_hucf5812b5d86ecfd34fcf071e0eca18dd_756053_720x0_resize_box_2.png 720w ,https://aignacio.com/posts/hdls/mpsoc_riscv/img/mpsoc_100x_white_hucf5812b5d86ecfd34fcf071e0eca18dd_756053_1080x0_resize_box_2.png 1080w ,https://aignacio.com/posts/hdls/mpsoc_riscv/img/mpsoc_100x_white_hucf5812b5d86ecfd34fcf071e0eca18dd_756053_1500x0_resize_box_2.png 1500w ,https://aignacio.com/posts/hdls/mpsoc_riscv/img/mpsoc_100x_white.png 1978w" sizes="(min-width: 768px) 720px, 100vw" src=https://aignacio.com/posts/hdls/mpsoc_riscv/img/mpsoc_100x_white.png alt="MPSoC diagram"><p>MPSoC diagram</p></figure><div class=toc><details><summary accesskey=c title="(Alt + C)"><div class=details>Table of Contents</div></summary><div class=inner><ul><li><a href=#intro aria-label=Intro>Intro</a></li><li><a href=#the-components aria-label="The components">The components</a></li><li><a href=#the-tiles aria-label="The tiles">The <em>tiles</em></a></li><li><a href=#simulation aria-label=Simulation>Simulation</a><ul><li><a href=#verilator-hint-for-mediumlarge-designs aria-label="Verilator hint for medium/large designs">Verilator hint for medium/large designs</a></li></ul></li><li><a href=#the-design-and-the-fpga aria-label="The design and the FPGA">The design and the FPGA</a><ul><li><a href=#fusesoc aria-label=FuseSoC>FuseSoC</a></li></ul></li><li><a href=#debugging-with-real-hardware aria-label="Debugging with real-hardware">Debugging with real-hardware</a></li></ul></div></details></div><div class=post-content><h2 id=intro>Intro<a hidden class=anchor aria-hidden=true href=#intro>#</a></h2><p>Although it looks slightly overkill, the idea behind this design was to check if my <a href=https://github.com/aignacio/ravenoc>NoC</a> (<em>Network-on-chip</em>) RTL would work into a real hardware &ldquo;FPGA&rdquo;. Then some weeks ago, during my summer holidays, I decided to put some effort into that, without any fancy approach but using a well-known RV core and my largest FPGA. So far till that moment, the only confirmation that the design was working as it&rsquo;s supposed to be, was through some <a href=https://github.com/aignacio/ravenoc/tree/master/tb>python tests</a> that were implemented to cover different aspects. Here below there is a resume of my short journey of implementing this <strong>MPSoC</strong> design.</p><h2 id=the-components>The components<a hidden class=anchor aria-hidden=true href=#the-components>#</a></h2><p>To compose the design, I wouldn&rsquo;t want to use anything proprietary or <em>platform-dependent</em>, such as Xilinx/Altera IPs, my main target was to design it all with open source <a href=https://github.com><em>Github</em></a> based components. Furthermore, I was planning to use an open-source simulation tool like <a href=https://github.com/verilator/verilator>Verilator</a> once if any user wants to try it out, no vendor thing would block from doing it. My only <em>tool</em> exception was to target my largest FPGA synthesis, where I&rsquo;ve used <a href=https://www.xilinx.com/products/design-tools/vivado.html>Vivado</a> to synthesize the design. It was in the queue to test how it&rsquo;d be with <a href=https://symbiflow.readthedocs.io/en/latest/prjxray/docs/architecture/overview.html>Symbiflow/Project x-ray</a>, however as I wasn&rsquo;t planning to spend an amount of time on this, I&rsquo;ve decided by the simple way IMO.</p><h2 id=the-tiles>The <em>tiles</em><a hidden class=anchor aria-hidden=true href=#the-tiles>#</a></h2><p>For this project, the first idea I had was the one I stayed with, so I had in my mind: build two tiles, one <strong>slave</strong> and one <strong>master</strong> and replicate it many times. With the master tile having a bit more stuff like JTAG and a larger data RAM. Also instead of having an Instruction RAM, I decided to use a boot ROM for the slave tiles with a simple program to answer master calls through the <a href=https://github.com/aignacio/ravenoc>NoC</a>. Again, nothing fancy just to see if I could request from the master to all slaves in the network. For the <a href=https://github.com/aignacio/mpsoc_example/blob/master/rtl/misc/tile_slave.sv>slave tile</a>, I defined the following components:</p><ul><li><a href=https://github.com/alexforencich/verilog-axi>AXI4 interconnect bus</a></li><li><a href=https://github.com/alexforencich/verilog-axi/blob/master/rtl/axi_ram.v>AXI4 memory</a></li><li><a href=https://github.com/aignacio/mpsoc_example/blob/master/rtl/misc/core/GenSmallestAXI4.scala>VexRISCV core (smallest cfg) with some tweaks to enable AXI4 and mtvec[RW] - RV32I</a></li><li><a href=https://github.com/aignacio/ravenoc/blob/master/src/ni/router_wrapper.sv>AXI4 NI <em>Network-Interface</em> with RaveNoC</a></li></ul><p><img loading=lazy src=img/slave_tile.png alt=slave_tile></p><p>Well, not that different for the <a href=https://github.com/aignacio/mpsoc_example/blob/master/rtl/misc/tile_master.sv>master tile</a> this is what I chose:</p><ul><li><a href=https://github.com/alexforencich/verilog-axi>AXI4 interconnect bus</a></li><li><a href=https://github.com/alexforencich/verilog-axi/blob/master/rtl/axi_ram.v>AXI4 memory</a></li><li><a href=https://github.com/aignacio/mpsoc_example/blob/master/rtl/misc/core/VexRiscvAxi4Jtag.scala>VexRISCV core (simple cfg) mult/div extension, full barrel shifter and has JTAG</a></li><li><a href=https://github.com/aignacio/ravenoc/blob/master/src/ni/router_wrapper.sv>AXI4 NI <em>Network-Interface</em> with RaveNoC</a></li></ul><p><img loading=lazy src=img/master_tile.png alt=master_tile></p><p>So that was all, pretty much straightforward hardware, nothing custom or different from what&rsquo;s already available on the web. With all that in place, I just encapsulated the NoC in the top and have added the <a href=https://www.verilogpro.com/verilog-generate-configurable-rtl/><em>generates</em></a>, having in the end, a smaller <a href=https://github.com/aignacio/mpsoc_example/blob/master/rtl/misc/mpsoc.sv>top</a> which has listed all the modules and instantiates a configurable number of tiles depending upon <a href=https://github.com/aignacio/mpsoc_example/blob/master/rtl/misc/ravenoc_defines.svh#L25>NoC size/cfg</a>. With the design ready, it was time to get some waves to check if everything was moving in a good direction.</p><p>The final design with all modules with a 9x9 RaveNoC is the following one:
<img loading=lazy src=img/mpsoc_100x_white.png alt=mpsoc></p><h2 id=simulation>Simulation<a hidden class=anchor aria-hidden=true href=#simulation>#</a></h2><p>For the simulation, as I had tried in the past, <a href=https://github.com/verilator/verilator>Verilator</a> was my best choice, once it&rsquo;s open-source and easy to write <em>testbenches</em> in <strong>cpp</strong>. Quickly copying and pasting from my previous personal projects, my <a href=https://github.com/aignacio/mpsoc_example/blob/master/tb/testbench.cpp>tb</a> has nothing but the <a href=https://github.com/aignacio/mpsoc_example/blob/master/tb/testbench.cpp#L186><em>dut</em></a> instantiation and a modified version of my ELF loader, which I was using at first to test boot ROM of slave tiles. Later on, I changed to only load the ELF into the master tile once the boot ROM on the slaves was working as it suppose to. To enable my cpp ELF loader to write into the memories, I implemented the functions below at the top of the tiles <a href=https://github.com/aignacio/mpsoc_example/blob/master/tb/testbench.cpp#L153>calling these in the tb</a> at sim #t0.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-verilog data-lang=verilog><span style=color:#75715e>// synthesis translate_off
</span><span style=color:#75715e></span>  <span style=color:#66d9ef>function</span> <span style=color:#66d9ef>automatic</span> <span style=color:#66d9ef>void</span> writeWordIRAM(addr_val, word_val);
    <span style=color:#75715e>/* verilator public */</span>
    <span style=color:#66d9ef>logic</span> [<span style=color:#ae81ff>31</span><span style=color:#f92672>:</span><span style=color:#ae81ff>0</span>] addr_val;
    <span style=color:#66d9ef>logic</span> [<span style=color:#ae81ff>31</span><span style=color:#f92672>:</span><span style=color:#ae81ff>0</span>] word_val;
    u_ram_instr_rv.u_ram.mem[addr_val] <span style=color:#f92672>=</span> word_val;
  <span style=color:#66d9ef>endfunction</span>

  <span style=color:#66d9ef>function</span> <span style=color:#66d9ef>automatic</span> <span style=color:#66d9ef>void</span> writeWordDRAM(addr_val, word_val);
    <span style=color:#75715e>/* verilator public */</span>
    <span style=color:#66d9ef>logic</span> [<span style=color:#ae81ff>31</span><span style=color:#f92672>:</span><span style=color:#ae81ff>0</span>] addr_val;
    <span style=color:#66d9ef>logic</span> [<span style=color:#ae81ff>31</span><span style=color:#f92672>:</span><span style=color:#ae81ff>0</span>] word_val;
    <span style=color:#75715e>//u_ram_rv.u_ram.mem[addr_val] = word_val;
</span><span style=color:#75715e></span>  <span style=color:#66d9ef>endfunction</span>
  <span style=color:#75715e>// synthesis translate_on
</span></code></pre></div><p>It&rsquo;s considerable to mention that the comment <em>"// synthesis translate_on/off"</em> was there to force Vivado to ignore these constructions when implementing. Technically that&rsquo;s not required because it&rsquo;s going to do that anyway although if you have hierarchical mention of the memory arrays like I do there, the tool <a href=https://github.com/alexforencich/verilog-axi/issues/17><strong>will not infer BRAMs</strong></a>, creating memories with LUTs what means that you&rsquo;re 1-wasting FPGA resources and 2-increasing the size of your design once it will consume a lot of logic slices for that.</p><p>My first attempt to communicate with the slaves through the NoC wasn&rsquo;t that good, I have forgotten to <a href=https://github.com/aignacio/mpsoc_example/blob/master/sw/tile_slave/init/startup.c#L61>change mtvec CSR</a> to point to the location where it was declared my external IRQ function. Thankfully after two/three cups of coffee, I was able to see the obvious in the sims. Since the beginning, I didn&rsquo;t want to code a complex handshake, so what I decided to do was to implement the following protocol between the single master and the 99x slaves:</p><p><img loading=lazy src=img/mpsoc_test_flowchart.png alt=flowchart></p><p>As the master tile has a JTAG interface I could easily switch from one slave coordinates to another without any worries, once it was as easy as compiling it again and loading through the I/F in the FPGA or through an ELF loader in my tb. With the boot ROM working and the master sending the packets correctly in the NoC, I saw it working after some runs. In the image below you can see the design being released from the reset, then the last slave in the NoC [aka x=9/y=9] receives an IRQ, reads the packet, operates on it, and sends it back to the master with the payload modified.</p><p><img loading=lazy src=img/communication_noc_verilator.png alt=verilator_sims></p><p><img loading=lazy src=img/happy.gif alt=me_when_worked></p><h3 id=verilator-hint-for-mediumlarge-designs>Verilator hint for medium/large designs<a hidden class=anchor aria-hidden=true href=#verilator-hint-for-mediumlarge-designs>#</a></h3><p>I guess worth it to explain here something I have done to speed up the <em>verilation</em> (process to convert from Verilog/RTL to cpp classes) when playing with my sims. When building something that can be considered a medium size design, the tool might take ages to run all the steps into conversion so I found something <a href=https://veripool.org/guide/latest/verilating.html#hierarchical-verilation>useful</a> in the Verilator&rsquo;s FAQ. This a way to indicate to Verilator that you have a design that&rsquo;s repeated many times and it can be processed into an <a href=https://github.com/aignacio/mpsoc_example/blob/master/config.vlt#L6>hierarchical way</a> or something like that. In my case, it changed from 120+ mins to 15 mins worst case. One of the drawbacks is that you need to remember to change the configuration file every time you change the wrapper name where is encapsulated the repetitive design because the output error seems a bit odd and it doesn&rsquo;t explain to you explicitly why it&rsquo;s failing to build (was almost mad when I discovered that xD). Another disadvantage is that you lose visibility of your structs and nested modules, although I suppose when you are building something like that, you pretty much already know what&rsquo;s going on inside there.</p><h2 id=the-design-and-the-fpga>The design and the FPGA<a hidden class=anchor aria-hidden=true href=#the-design-and-the-fpga>#</a></h2><p>When I first saw it working on sims, I was pretty much confident it&rsquo;d work straight away on the FPGA once I wasn&rsquo;t adding any MMCM, clock generators, or anything <em>vendor/part-number</em> specific. However, I didn&rsquo;t start with 100x cores in my first synth and I knew that would fit in my board, unfortunately, I don&rsquo;t have a crystal ball. So I started with an 8x8 design and discovered that my NoC with 2x <em>flits</em> buffer was consuming a considerable amount of the whole design LUT space. And my FPGA is a Kintex 7 - xc7k325tffg676-2 which has around >203k LUT in total.
<img loading=lazy src=img/k7_fpga.jpg alt=k7_fpga></p><p>Having an <a href=https://github.com/aignacio/mpsoc_example/blob/master/rtl/misc/ravenoc_defines.svh>easily configurable</a> NoC was the advantage on playing with the parameters to see how big I could increase my design and/or shrink some internal buffers. After several tries and decreasing my initial VexRISCV core parameters to the smallest possible option I could synthesize with <strong>100x RISC-V cores running @ 100MHz</strong>. Again, the initial idea wasn&rsquo;t to push 100% utilization but if it&rsquo;s easy to change and it&rsquo;s interesting to know, why not?!. My final hierarchical report by area utilization was <a href=https://github.com/aignacio/mpsoc_example/blob/master/mpsoc_100xfinal_report_synth.rpt>this one</a> in the end.</p><p><img loading=lazy src=img/utilization_1.png alt=util_1>
<img loading=lazy src=img/utilization_2.png alt=util_2></p><p>In the end, I had only 3% LUT space left! Still would fit another VexRISCV with steroids, but I was too lazy to try that, maybe another time. The whole congestion/timing in the design wasn&rsquo;t much awful, as I was running in a low clock freq. for this PN (@100MHz).
<img loading=lazy src=img/utilization_3.png alt=util_3>
As you can see in the image above, almost every logical slice has something placed, let&rsquo;s give some thumbs up to Xilinx&rsquo;s tools at least. xD</p><h3 id=fusesoc>FuseSoC<a hidden class=anchor aria-hidden=true href=#fusesoc>#</a></h3><p>My main source of headaches when dealing with vendor&rsquo;s tools is to call TCL scripts and face a heterogeneous set of issues about wrong setup, missing files, and a bunch of other &ldquo;<em>waste of time</em>&rdquo; stuff. I don&rsquo;t remember well but most likely that was my motivation when I started looking for a replacement solution. Thankfully there&rsquo;re impressive engineers such as <a href=https://github.com/olofk>Olof</a> which started developing some years ago a python package tool called <a href=https://github.com/olofk/fusesoc><strong>FuseSoC</strong></a> that works as a mixer i.e it takes all your old past frustrations with FPGA vendors + your disruptive RTLs and your ctrl+c/v constraints file and builds for you a <strong>bitstream</strong>.</p><p><img loading=lazy src=img/fusesoc.png alt=fusesoc></p><p>Eventually, when it finishes it&rsquo;ll also try to program your device magically, it&rsquo;s fantastic and worth giving a try if you never saw it before. Your only duty as a user is to create a YAML <a href=https://github.com/aignacio/mpsoc_example/blob/master/example_mpsoc.core>core config file</a> that will list all your RTLs/constraints/PN and point that to the tool. Of course, it&rsquo;s implicit you need to have the vendor tool installed for your FPGA, although it&rsquo;s magic, the <em>hocus pocus</em> about a license is still required if you&rsquo;re in Xilinx/Altera&rsquo;s world. If you&rsquo;re willing to build this MPSoC for your FPGA, just be careful when launching a run once it takes some time to finish it&mldr;</p><p><img loading=lazy src=img/fpga_meme.webp alt=fpga_meme></p><h2 id=debugging-with-real-hardware>Debugging with real-hardware<a hidden class=anchor aria-hidden=true href=#debugging-with-real-hardware>#</a></h2><p>After programming the 10.2MB bitstream in the FPGA through Vivado (need to try through <a href=https://github.com/trabucayre/openFPGALoader>open FPGA loader</a>) and connecting the JTAG adapter in the headers, it was time for debugging the program with a real emulation. One of the advantages of using VexRISCV is that the debug module is easy to use and it implements methods to access the busses of the core and put breakpoints/watchpoints all over your SW. For the use with my design, I just downloaded and built their <a href=https://github.com/SpinalHDL/openocd_riscv>openocd</a> version and in no time was able to start debugging.</p><p>To connect the jtag adapter with openocd and start the gdb server:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>$ mpsoc_example/sw/openocd_vexriscv -f mpsoc_example/sw/esp-prog.cfg -c <span style=color:#e6db74>&#34;set MPSOC /home/aignacio/mpsoc_example/sw/cpu0.yaml&#34;</span> -f mpsoc_example/sw/mpsoc.cfg
</code></pre></div><p>And to launch gdb connecting to the server and sending the ELF file:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>$ riscv64-unknown-elf-gdb output/tile_master.elf -ex <span style=color:#e6db74>&#34;target remote localhost:3333&#34;</span> -ex <span style=color:#e6db74>&#34;load&#34;</span>
</code></pre></div><p>With the gdb session opened, I just set a breakpoint at the IRQ after reading the RX NI buffer of NoC to see what was the returned packet content.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=color:#f92672>(</span>gdb<span style=color:#f92672>)</span> b main.c:47 
<span style=color:#f92672>(</span>gdb<span style=color:#f92672>)</span> c <span style=color:#75715e>#Run till bp</span>
<span style=color:#f92672>(</span>gdb<span style=color:#f92672>)</span> p/x buffer <span style=color:#75715e>#print in hex the buffer value</span>
</code></pre></div><p><strong>&mldr;finally here&rsquo;s my debug session with the results when talking with the FPGA</strong>
<img loading=lazy src=img/debugging.png alt=voilá>
As it can be seen, the last slave tile answers properly as it is supposed to be. I also tried with different slaves and had the same results changing of course the source X/Y in the payload, all operating as they should.</p><p><img loading=lazy src=img/end.gif alt=end></p><p>To have access to the design, FuseSoC configuration file, sims, and testbench, please check <a href=https://github.com/aignacio/mpsoc_example>this repository</a>.</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://aignacio.com/tags/hdl/>hdl</a></li></ul><nav class=paginav><a class=next href=https://aignacio.com/posts/hdls/cdc_lib/><span class=title>Next Page »</span><br><span>My two cents about CDC</span></a></nav><div class=share-buttons><a target=_blank rel="noopener noreferrer" aria-label="share How to fit 100x RISC-V cores into an FPGA on twitter" href="https://twitter.com/intent/tweet/?text=How%20to%20fit%20100x%20RISC-V%20cores%20into%20an%20FPGA&url=https%3a%2f%2faignacio.com%2fposts%2fhdls%2fmpsoc_riscv%2f&hashtags=hdl"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM195.519 424.544c135.939.0 210.268-112.643 210.268-210.268.0-3.218.0-6.437-.153-9.502 14.406-10.421 26.973-23.448 36.935-38.314-13.18 5.824-27.433 9.809-42.452 11.648 15.326-9.196 26.973-23.602 32.49-40.92-14.252 8.429-30.038 14.56-46.896 17.931-13.487-14.406-32.644-23.295-53.946-23.295-40.767.0-73.87 33.104-73.87 73.87.0 5.824.613 11.494 1.992 16.858-61.456-3.065-115.862-32.49-152.337-77.241-6.284 10.881-9.962 23.601-9.962 37.088.0 25.594 13.027 48.276 32.95 61.456-12.107-.307-23.448-3.678-33.41-9.196v.92c0 35.862 25.441 65.594 59.311 72.49-6.13 1.686-12.72 2.606-19.464 2.606-4.751.0-9.348-.46-13.946-1.38 9.349 29.426 36.628 50.728 68.965 51.341-25.287 19.771-57.164 31.571-91.8 31.571-5.977.0-11.801-.306-17.625-1.073 32.337 21.15 71.264 33.41 112.95 33.41z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share How to fit 100x RISC-V cores into an FPGA on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&url=https%3a%2f%2faignacio.com%2fposts%2fhdls%2fmpsoc_riscv%2f&title=How%20to%20fit%20100x%20RISC-V%20cores%20into%20an%20FPGA&summary=How%20to%20fit%20100x%20RISC-V%20cores%20into%20an%20FPGA&source=https%3a%2f%2faignacio.com%2fposts%2fhdls%2fmpsoc_riscv%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share How to fit 100x RISC-V cores into an FPGA on reddit" href="https://reddit.com/submit?url=https%3a%2f%2faignacio.com%2fposts%2fhdls%2fmpsoc_riscv%2f&title=How%20to%20fit%20100x%20RISC-V%20cores%20into%20an%20FPGA"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share How to fit 100x RISC-V cores into an FPGA on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2faignacio.com%2fposts%2fhdls%2fmpsoc_riscv%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share How to fit 100x RISC-V cores into an FPGA on whatsapp" href="https://api.whatsapp.com/send?text=How%20to%20fit%20100x%20RISC-V%20cores%20into%20an%20FPGA%20-%20https%3a%2f%2faignacio.com%2fposts%2fhdls%2fmpsoc_riscv%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share How to fit 100x RISC-V cores into an FPGA on telegram" href="https://telegram.me/share/url?text=How%20to%20fit%20100x%20RISC-V%20cores%20into%20an%20FPGA&url=https%3a%2f%2faignacio.com%2fposts%2fhdls%2fmpsoc_riscv%2f"><svg viewBox="2 2 28 28"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></div></footer></article></main><footer class=footer><span>&copy; 2021 <a href=https://aignacio.com/>aignacio</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)"><button class=top-link id=top-link type=button accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></button></a>
<script>let menu=document.getElementById('menu');menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)},document.querySelectorAll('a[href^="#"]').forEach(a=>{a.addEventListener("click",function(b){b.preventDefault();var a=this.getAttribute("href").substr(1);window.matchMedia('(prefers-reduced-motion: reduce)').matches?document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView({behavior:"smooth"}),a==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${a}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove('dark'),localStorage.setItem("pref-theme",'light')):(document.body.classList.add('dark'),localStorage.setItem("pref-theme",'dark'))})</script><script>document.querySelectorAll('pre > code').forEach(b=>{const c=b.parentNode.parentNode,a=document.createElement('button');a.classList.add('copy-code'),a.innerText='copy';function d(){a.innerText='copied!',setTimeout(()=>{a.innerText='copy'},2e3)}a.addEventListener('click',e=>{if('clipboard'in navigator){navigator.clipboard.writeText(b.textContent),d();return}const a=document.createRange();a.selectNodeContents(b);const c=window.getSelection();c.removeAllRanges(),c.addRange(a);try{document.execCommand('copy'),d()}catch(a){}c.removeRange(a)}),c.classList.contains("highlight")?c.appendChild(a):c.parentNode.firstChild==c||(b.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?b.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(a):b.parentNode.appendChild(a))})</script></body></html>